<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bloom Controls</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-user-select: none;
    }
    #box {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 16px;
      min-width: 280px;
      position: relative;
      transition: all 0.3s ease;
      color: #333;
    }
    #box.collapsed {
      min-width: auto;
      width: 40px;
      height: 200px;
      padding: 0;
      border-radius: 20px;
      display: flex;
      position: relative;
    }
    #header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      cursor: move;
      padding: 4px;
      border-radius: 8px;
      transition: background 0.2s;
    }
    #header:hover {
      background: rgba(0, 0, 0, 0.02);
    }
    #headerLogo {
      height: 70px;
      width: auto;
      transition: opacity 0.2s;
    }
    .logo-collapsed {
      height: 40px;
      width: auto;
    }
    #headerLogo:hover {
      opacity: 1;
    }
    #toggleBtn {
      background: rgba(0, 0, 0, 0.05);
      border: none;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    #toggleBtn:hover {
      background: rgba(0, 0, 0, 0.1);
      color: #333;
    }
    #content {
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    #box.collapsed #content {
      opacity: 0;
      transform: scale(0.8);
      pointer-events: none;
      position: absolute;
      visibility: hidden;
    }
    #box.collapsed #header {
      margin: 0;
      justify-content: center;
    }
    .camera-section {
      margin-bottom: 16px;
    }
    .camera-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .camera-icon {
      font-size: 16px;
      color: #666;
    }
    .camera-status {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }
    .camera-status.off {
      color: #999;
    }
    .camera-toggle {
      margin-left: auto;
      width: 48px;
      height: 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }
    .camera-toggle.off {
      background: #ddd;
    }
    .camera-toggle.on {
      background: #ffce07;
    }
    .camera-toggle::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      top: 2px;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .camera-toggle.off::after {
      left: 2px;
    }
    .camera-toggle.on::after {
      left: 26px;
    }
    .camera-dropdown {
      margin-top: 8px;
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      color: #333;
      cursor: pointer;
      transition: all 0.2s;
    }
    .camera-dropdown:hover {
      border-color: #ffce07;
    }
    .camera-dropdown:focus {
      outline: none;
      border-color: #ffce07;
      box-shadow: 0 0 0 3px rgba(255, 206, 7, 0.1);
    }
    .camera-dropdown option {
      padding: 8px;
    }
    .microphone-section {
      margin-bottom: 16px;
    }
    .microphone-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .microphone-icon {
      font-size: 16px;
      color: #ffce07;
    }
    .microphone-label {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }
    .microphone-status {
      margin-left: auto;
      font-size: 12px;
      color: #ffce07;
      background: rgba(255, 206, 7, 0.1);
      padding: 4px 8px;
      border-radius: 12px;
    }
    .recording-section {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }
    .record-btn {
      width: 95%;
      min-width: 120px;
      height: 44px;
      border: none;
      border-radius: 22px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
      background: #ff4757;
      color: white;
      position: relative;
      padding: 0 20px;
    }
    .record-btn:hover {
      background: #ff3838;
      transform: scale(1.05);
    }
    .record-btn.recording {
      background: #ff4757;
      animation: pulse 2s infinite;
    }
    .record-btn.recording::after {
      content: '';
      position: absolute;
      top: -4px;
      left: -4px;
      right: -4px;
      bottom: -4px;
      border: 2px solid #ff4757;
      border-radius: 26px;
      opacity: 0.3;
      animation: ripple 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    @keyframes ripple {
      0% { transform: scale(1); opacity: 0.3; }
      100% { transform: scale(1.2); opacity: 0; }
    }
    .recording-time {
      text-align: center;
      font-size: 12px;
      color: #ff4757;
      font-weight: 500;
      margin-top: 8px;
    }
    .lock-section {
      margin-bottom: 16px;
    }
    .lock-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .lock-icon {
      font-size: 16px;
      color: #666;
    }
    .lock-label {
      font-size: 14px;
      font-weight: 500;
      color: #333;
      flex: 1;
    }
    .lock-toggle {
      margin-left: auto;
      width: 48px;
      height: 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }
    .lock-toggle.off {
      background: #ddd;
    }
    .lock-toggle.on {
      background: #ffce07;
    }
    .lock-toggle::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      top: 2px;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .lock-toggle.off::after {
      left: 2px;
    }
    .lock-toggle.on::after {
      left: 26px;
    }
    .resize-section {
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(255, 206, 7, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(255, 206, 7, 0.1);
    }
    .resize-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .resize-icon {
      font-size: 16px;
      color: #ffce07;
    }
    .resize-label {
      font-size: 14px;
      font-weight: 600;
      color: #ffce07;
      flex: 1;
    }
    .resize-controls {
      display: flex;
      gap: 6px;
      justify-content: space-between;
    }
    .resize-btn {
      flex: 1;
      height: 36px;
      border: 2px solid #ffce07;
      border-radius: 8px;
      background: white;
      color: #ffce07;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .resize-btn:hover {
      border-color: #e6b806;
      background: rgba(255, 206, 7, 0.1);
      color: #e6b806;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(255, 206, 7, 0.2);
    }
    .resize-btn.active {
      background: #ffce07;
      color: white;
      border-color: #ffce07;
      box-shadow: 0 2px 4px rgba(255, 206, 7, 0.3);
    }
    .custom-resize {
      font-size: 16px;
      min-width: 36px;
      flex: 0;
    }
    .status {
      text-align: center;
      font-size: 11px;
      color: #999;
      background: rgba(0, 0, 0, 0.03);
      padding: 8px;
      border-radius: 8px;
      margin-top: 8px;
    }
    .hidden {
      display: none;
    }
    
    /* Collapsed Status Bar Styles */
    #collapsed-status {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      font-size: 14px;
      height: 100%;
      width: 100%;
      padding: 40px 0 16px 0; /* Top padding to avoid expand button */
      box-sizing: border-box;
    }
    
    .status-indicator {
      font-size: 22px;
      opacity: 0.3;
      transition: opacity 0.2s;
      text-align: center;
      color: #666;
    }
    
    .status-indicator.active {
      opacity: 1;
      color: #ffce07;
    }
    
    .status-indicator.recording {
      color: #ff4757;
      animation: pulse 2s infinite;
    }
    
    .status-time {
      font-size: 10px;
      font-weight: 700;
      color: #ff4757;
      min-width: 30px;
      text-align: center;
      opacity: 0.9;
      display: none;
    }
    
    /* Collapsed state visibility rules */
    #box.collapsed #collapsed-status {
      display: flex;
    }
    
    #box:not(.collapsed) #collapsed-status {
      display: none;
    }
    
    #box.collapsed #content {
      display: none;
    }
    
    #box.collapsed #header {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      padding: 4px;
    }
    
    #box.collapsed #headerLogo {
      display: none;
    }
    
    #box.collapsed #toggleBtn {
      width: 20px;
      height: 20px;
      font-size: 14px;
      opacity: 0.8;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: #333;
    }
    
    #box.collapsed #toggleBtn:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.05);
    }
  </style>
</head>
<body>
  <div id="box">
    <div id="header">
      <img src="assets/bloom-app-header.png" alt="Bloom" id="headerLogo" />
      <button id="toggleBtn" title="Toggle controls">×</button>
    </div>
    
    <!-- Collapsed Status Bar (only visible when collapsed) -->
    <div id="collapsed-status">
      <img src="assets/icon.png" alt="Bloom" class="logo-collapsed"/>
      <span id="webcam-indicator" class="status-indicator" title="Webcam">📹</span>
      <span id="recording-indicator" class="status-indicator" title="Recording">⏺</span>
      <span id="recording-time-collapsed" class="status-time">0:00</span>
    </div>
    
    <div id="content">
      <!-- Camera Section -->
      <div class="camera-section">
        <div class="camera-header">
          <span class="camera-icon">📹</span>
          <span class="camera-status" id="cameraStatus">No Camera</span>
          <button class="camera-toggle off" id="cameraToggle"></button>
        </div>
        <select class="camera-dropdown" id="cameraSelect" style="display: none;">
          <option value="">Select Camera...</option>
        </select>
      </div>

      <!-- Microphone Section -->
      <div class="microphone-section">
        <div class="microphone-header">
          <span class="microphone-icon">🎤</span>
          <span class="microphone-label" id="microphoneLabel">Default - Detecting...</span>
          <span class="microphone-status">On</span>
        </div>
      </div>

      <!-- Recording Section -->
      <div class="recording-section">
        <button class="record-btn" id="recordBtn" title="Start Recording">
          Start Recording
        </button>
      </div>
      <div class="recording-time hidden" id="recordingTime">0:00</div>

      <!-- Lock Toggle Section -->
      <div class="lock-section">
        <div class="lock-header">
          <span class="lock-icon">🔒</span>
          <span class="lock-label">Lock Position</span>
          <button class="lock-toggle off" id="lockToggle"></button>
        </div>
      </div>

      <div class="status" id="status">Camera issue detected</div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require("electron");
    const cameraSelect = document.getElementById("cameraSelect");
    const cameraStatus = document.getElementById("cameraStatus");
    const cameraToggle = document.getElementById("cameraToggle");
    const lockToggle = document.getElementById("lockToggle");
    const recordBtn = document.getElementById("recordBtn");
    const recordingTime = document.getElementById("recordingTime");
    const status = document.getElementById("status");
    const toggleBtn = document.getElementById("toggleBtn");
    const box = document.getElementById("box");
    const microphoneLabel = document.getElementById("microphoneLabel");
    
    // Collapsed status elements
    const webcamIndicator = document.getElementById("webcam-indicator");
    const recordingIndicator = document.getElementById("recording-indicator");
    const recordingTimeCollapsed = document.getElementById("recording-time-collapsed");
    
    let isOverlayActive = false;
    let isCollapsed = false;
    let isRecording = false;
    let isCameraOn = false;
    let isLocked = false; // Changed default to false (unlocked)
    let recordingInterval;
    let recordingStartTime;

    // Drag functionality for controls window
    let dragging = false, dragOffsetX = 0, dragOffsetY = 0;

    // Make the header the primary drag handle
    const header = document.getElementById("header");
    header.addEventListener("mousedown", (e) => {
      if (isLocked) return; // Don't drag when locked
      if (isCollapsed) return; // Don't drag when collapsed (too small)
      
      // Don't start drag if clicking the toggle button
      if (e.target.id === 'toggleBtn') {
        return;
      }
      
      dragging = true;
      dragOffsetX = e.clientX;
      dragOffsetY = e.clientY;
      e.preventDefault();
    });

    // Also allow dragging from the main box area (avoiding interactive elements)
    box.addEventListener("mousedown", (e) => {
      if (isLocked) return;
      
      // Don't start drag on interactive elements
      if (e.target.tagName === 'BUTTON' || 
          e.target.tagName === 'SELECT' || 
          e.target.tagName === 'OPTION' ||
          e.target.closest('#header')) { // Skip if already handled by header
        return;
      }
      
      dragging = true;
      dragOffsetX = e.clientX;
      dragOffsetY = e.clientY;
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      // Calculate new position based on screen coordinates
      const newX = e.screenX - dragOffsetX;
      const newY = e.screenY - dragOffsetY;
      ipcRenderer.send("move-controls", newX, newY);
    });

    window.addEventListener("mouseup", () => {
      dragging = false;
    });

    // Toggle collapse/expand
    toggleBtn.addEventListener("click", () => {
      isCollapsed = !isCollapsed;
      if (isCollapsed) {
        box.classList.add("collapsed");
        toggleBtn.textContent = "▶";
        toggleBtn.title = "Expand controls";
        ipcRenderer.send("resize-controls", 60, 280); // Increased height to accommodate expand button
        updateCollapsedStatus(); // Update status indicators when collapsed
      } else {
        box.classList.remove("collapsed");
        toggleBtn.textContent = "×";
        toggleBtn.title = "Collapse controls";
        ipcRenderer.send("resize-controls", 320, 500);
      }
    });

    // Update collapsed status indicators
    function updateCollapsedStatus() {
      // Update webcam indicator
      if (isCameraOn) {
        webcamIndicator.classList.add("active");
      } else {
        webcamIndicator.classList.remove("active");
      }
      
      // Update recording indicator
      if (isRecording) {
        recordingIndicator.classList.add("active", "recording");
        recordingTimeCollapsed.style.display = "block";
      } else {
        recordingIndicator.classList.remove("active", "recording");
        recordingTimeCollapsed.style.display = "none";
      }
    }
    
    function updateCollapsedRecordingTime() {
      if (!isRecording) return;
      
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      recordingTimeCollapsed.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Load available cameras and microphones
    async function loadCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const audioDevices = devices.filter(device => device.kind === 'audioinput');
        
        // Load cameras
        cameraSelect.innerHTML = '<option value="">Select Camera...</option>';
        if (videoDevices.length === 0) {
          cameraStatus.textContent = "No Camera";
          cameraStatus.classList.add("off");
          cameraToggle.disabled = true;
          status.textContent = "No cameras available";
        } else {
          videoDevices.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Camera ${index + 1}`;
            cameraSelect.appendChild(option);
          });
          
          // Set first camera as default
          cameraSelect.value = videoDevices[0].deviceId;
          cameraStatus.textContent = videoDevices[0].label || "Camera 1";
          cameraStatus.classList.remove("off");
          status.textContent = "Ready to record";
        }
        
        // Set default microphone label
        if (audioDevices.length > 0) {
          const defaultMic = audioDevices[0];
          const micName = defaultMic.label || "Built-in Microphone";
          microphoneLabel.textContent = `${micName}`;
        } else {
          microphoneLabel.textContent = "Default - No Microphone Available";
        }
        
      } catch (err) {
        console.error("Error loading devices:", err);
        cameraStatus.textContent = "Camera Error";
        cameraStatus.classList.add("off");
        microphoneLabel.textContent = "Default - Device Error";
        status.textContent = "Device access issue detected";
        cameraToggle.disabled = true;
      }
    }

    // Camera toggle
    cameraToggle.addEventListener("click", () => {
      if (cameraToggle.disabled) return;
      
      isCameraOn = !isCameraOn;
      
      if (isCameraOn) {
        cameraToggle.classList.remove("off");
        cameraToggle.classList.add("on");
        cameraSelect.style.display = "block";
        
        const selectedCamera = cameraSelect.value;
        if (selectedCamera) {
          ipcRenderer.send("start-overlay", selectedCamera);
          isOverlayActive = true;
          status.textContent = "Camera active";
        }
      } else {
        cameraToggle.classList.remove("on");
        cameraToggle.classList.add("off");
        cameraSelect.style.display = "none";
        
        if (isOverlayActive) {
          ipcRenderer.send("stop-overlay");
          isOverlayActive = false;
        }
        status.textContent = "Camera off";
      }
      
      updateCollapsedStatus(); // Update collapsed status indicators
    });

    // Camera selection change
    cameraSelect.addEventListener("change", () => {
      if (isCameraOn && cameraSelect.value) {
        ipcRenderer.send("stop-overlay");
        setTimeout(() => {
          ipcRenderer.send("start-overlay", cameraSelect.value);
          status.textContent = "Camera switched";
        }, 100);
      }
      
      if (cameraSelect.value) {
        const selectedOption = cameraSelect.options[cameraSelect.selectedIndex];
        cameraStatus.textContent = selectedOption.textContent;
      }
    });

    // Lock toggle
    lockToggle.addEventListener("click", () => {
      isLocked = !isLocked;
      
      if (isLocked) {
        lockToggle.classList.remove("off");
        lockToggle.classList.add("on");
      } else {
        lockToggle.classList.remove("on");
        lockToggle.classList.add("off");
      }
      
      ipcRenderer.send("set-lock", isLocked);
    });



    // Start/Stop recording
    recordBtn.addEventListener("click", () => {
      if (!isRecording) {
        // Start recording
        isRecording = true;
        recordBtn.classList.add("recording");
        recordBtn.textContent = "Stop Recording";
        recordBtn.title = "Stop Recording";
        recordingTime.classList.remove("hidden");
        
        recordingStartTime = Date.now();
        recordingInterval = setInterval(() => {
          updateRecordingTime();
          updateCollapsedRecordingTime();
        }, 1000);
        
        updateCollapsedStatus(); // Update collapsed status indicators
        ipcRenderer.send("start-recording");
        status.textContent = "Recording...";
      } else {
        // Stop recording
        stopRecording();
        ipcRenderer.send("stop-recording");
      }
    });

    function stopRecording() {
      isRecording = false;
      recordBtn.classList.remove("recording");
      recordBtn.textContent = "Start Recording";
      recordBtn.title = "Start Recording";
      recordingTime.classList.add("hidden");
      
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
      
      updateCollapsedStatus(); // Update collapsed status indicators
      
      status.textContent = "Recording saved";
      setTimeout(() => {
        status.textContent = isCameraOn ? "Camera active" : "Ready to record";
      }, 2000);
    }

    function updateRecordingTime() {
      if (!isRecording) return;
      
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Handle overlay status updates from main process
    ipcRenderer.on("overlay-status", (_, active) => {
      isOverlayActive = active;
      if (!active && isCameraOn) {
        // Camera was turned off externally
        isCameraOn = false;
        cameraToggle.classList.remove("on");
        cameraToggle.classList.add("off");
        cameraSelect.style.display = "none";
        status.textContent = "Camera off";
      }
    });

    // Handle recording status updates
    ipcRenderer.on("recording-status", (_, recording) => {
      if (!recording && isRecording) {
        stopRecording();
      }
    });

    // Handle recording saved notification
    ipcRenderer.on("recording-saved", (_, filePath) => {
      status.textContent = `Recording saved to Desktop`;
    });

    // Handle recording errors
    ipcRenderer.on("recording-error", (_, error) => {
      status.textContent = `Recording error: ${error}`;
      if (isRecording) {
        stopRecording();
      }
    });

    // Handle when user ends recording via system controls
    ipcRenderer.on("recording-ended-by-user", () => {
      if (isRecording) {
        stopRecording();
      }
    });

    // Handle lock state changes from main process
    ipcRenderer.on("lock-changed", (_, locked) => {
      isLocked = !!locked;
      if (isLocked) {
        lockToggle.classList.remove("off");
        lockToggle.classList.add("on");
      } else {
        lockToggle.classList.remove("on");
        lockToggle.classList.add("off");
      }
    });

    // Load cameras when page loads
    loadCameras();
    
    // Initialize collapsed status indicators
    updateCollapsedStatus();

    // Reload cameras when devices change
    navigator.mediaDevices.addEventListener('devicechange', loadCameras);
  </script>
</body>
</html>
